class Stream::Multi < Stream::Base

  # @param user [User]
  # @param inputted_aspect_ids [Array<Integer>] Ids of aspects for given stream
  # @param inputted_tag_ids [Array<Integer>] Ids of tags for this given stream
  # @opt max_time [Integer] Unix timestamp of stream's post ceiling
  # @opt order [String] Order of posts (i.e. 'created_at', 'updated_at')
  # @return [void]
  def initialize(user, inputted_aspect_ids, inputted_tag_ids, opts={})
    super(user, opts)
    @inputted_aspect_ids = inputted_aspect_ids
    @inputted_tag_ids = inputted_tag_ids
    if opts[:all_aspects]
      @all_aspects = true
    end
    if opts[:all_tags]
      @all_tags = true
    end
  end

  # @return [String] URL
  def link(opts)
    Rails.application.routes.url_helpers.multi_path(opts)
  end

  # @return [String]
  def title
    I18n.t('streams.multi.title')
  end

  # @return [String]
  def contacts_title
    I18n.t('streams.multi.contacts_title.')
  end

  # Provides a link to the user to the contacts page that corresponds with
  # the stream's active aspects.
  #
  # @return [String] Link to contacts
  def contacts_link
    if for_all_aspects? || aspect_ids.size > 1
      Rails.application.routes.url_helpers.contacts_path
    else
      Rails.application.routes.url_helpers.contacts_path(:a_id => aspect.id)
    end
  end

  def posts
    @posts ||= lambda do
      #TODO(dk): clear me when this list is: 1) autogenerated (ie, arbitrary types) and 2) filterable (metawhere)
      post_ids = aspects_post_ids + tags_post_ids + mentioned_post_ids
      post_ids += community_spotlight_post_ids if include_community_spotlight?
      Post.where(:id => post_ids)
    end.call
  end

  # @return [Boolean]
  def ajax_stream?
    !AppConfig[:redis_cache] && for_everything?
  end

  def aspects
    @aspects ||= lambda do
      a = user.aspects
      a = a.where(:id => @inputted_aspect_ids) unless @all_aspects
      a
    end.call
  end

  def aspect_ids
    @aspect_ids ||= aspects ? aspects.map { |a| a.id } : []
  end

  def tag_ids
    @tag_ids ||= tags ? tags.map{|t| t.id} : []
  end

  def for_all_tags?
    @all_tags or (tags and (tags.size == user.followed_tags.size))
  end

  def for_all_aspects?
    @all_aspects or (aspects and (aspects.size == user.aspects.size))
  end

  def for_everything?
    for_all_tags? and for_all_aspects?
  end

  # @return [ActiveRecord::Association<Person>] AR association of people within stream's given aspects
  def people
    people_ids = Person.all_from_aspects(aspect_ids, user).includes(:profile)
    people_ids += posts.map{|x| x.author_id}
    Person.where(:id => people_ids).includes(:profile)
  end

  # I18n.t("shared.publisher.new_user_prefill.i_like", :tags => tag_string)    # TODO(dk): use this pattern as a way to map filter params to user readable stream title (but also edited by user)

  #emits an enum of the groups which the post appeared
  # :spotlight, :aspects, :tags, :mentioned
  def post_from_group(post)
    streams_included.collect do |source|
      is_in?(source, post)
    end.compact
  end


  private

  # @return [Array<Symbol>]
  def streams_included
    @streams_included ||= lambda do
      array = [:mentioned, :aspects, :tags] # TODO(dk): arbitrary types
      array << :community_spotlight if include_community_spotlight?
      array
    end.call
  end

  # @return [Symbol]
  def is_in?(sym, post)
    if self.send("#{sym.to_s}_post_ids").find{|x| (x == post.id) || (x.to_s == post.id.to_s)}
      if sym.to_s == "tags"
         "followed_tags_stream".to_sym
      else
        "#{sym.to_s}_stream".to_sym
      end
    end
  end

  # @return [Boolean]
  def include_community_spotlight?                 # TODO(dk): this should just be a filter param
    AppConfig[:community_spotlight].present? && user.show_community_spotlight_in_stream?
  end

  def aspects_post_ids
    result = @aspects_post_ids ||= user.visible_shareable_ids(Post, :limit => 15, :order => "#{order} DESC", :max_time => max_time, :by_members_of => aspect_ids)
    print "aspect post ids for user #{user} are #{result.join(', ')} when ordered #{order} at max time #{max_time} for aspect ids #{aspect_ids}\n"
    result
  end

  def tags_post_ids
    @tags_post_ids ||= for_all_aspects? ? ids(StatusMessage.public_tag_stream(tag_ids)) : ids(StatusMessage.user_tag_stream(user, tag_ids))
  end

  def mentioned_post_ids          # TODO(dk): user-supplied values
    @mentioned_post_ids ||= ids(StatusMessage.where_person_is_mentioned(user.person).for_a_stream(max_time, order))
  end

  def community_spotlight_post_ids            # TODO(dk): user-supplied values
    @community_spotlight_post_ids ||= ids(Post.all_public.where(:author_id => community_spotlight_person_ids).for_a_stream(max_time, order))
  end

  #worthless helpers
  def community_spotlight_person_ids       # TODO(dk): user-supplied values
    @community_spotlight_person_ids ||= Person.community_spotlight.select('id').map{|x| x.id}
  end

  def tags
    @tags ||= lambda do
      t = user.followed_tags
      t = t.where(:id => @inputted_tag_ids) unless @all_tags
      t
    end.call
  end

  def ids(enumerable)
    Post.connection.select_values(enumerable.select('posts.id').to_sql)
  end
end
